(defstruct node
  contents
  variance
  right
  left
  )

(defun compass (mitigations &key (min-cluster-size 4) (distance-func 'cosine-similarity) (variance-func 'variance))
  (let ((tree (make-node
	       :variance (funcall variance-func mitigations)
	       :contents mitigations)))

    ; Recursive node-walker
    (labels ((walk (node)
	       (let ((node-split (separate (node-contents node))))
		 (if (> (length (first node-split)) 1)
		     (setf (node-left node)
			   (make-node
			    :variance (funcall variance-func (first node-split))
			    :contents (first node-split))))
		 (if (> (length (second node-split)) 1)
		     (setf (node-right node)
			   (make-node
			    :variance (funcall variance-func (second node-split))
			    :contents (second node-split))))
		 (unless (null (node-left node))
		   (if (> (length (node-contents (node-left node))) min-cluster-size)
		       (walk (node-left node))))
		 (unless (null (node-right node))
		   (if (> (length (node-contents (node-right node))) min-cluster-size)
		       (walk (node-right node)))))))

      ; Recursively build upon each node
      (walk tree)
      tree)))

(defun print-nodes (tree &optional (stream *standard-output*))
  "Pretty print built nodes"
  (labels ((walk (node &optional (level 0))
	     (format stream "LEVEL: ~A~%" level)
	     (format stream "VARIANCE: ~A~%" (node-variance node))
	     (format stream "CONTENTS:~%")
	     (dolist (element (node-contents node))
	       (format stream "~A~%" element))
	     (format stream "~%~%")
	     (if (not (null (node-right node)))
		 (walk (node-right node) (1+ level)))
	     (if (not (null (node-left node)))
		 (walk (node-left node) (1+ level)))))
    (walk tree)))

(defun test-compass (file mitigations)
  "Sample run"
  (with-open-file (stream file
                          :direction :output
                          :if-exists :supersede
                          :if-does-not-exist :create )
    (let* ((compass-tree (compass mitigations :distance-func 'cosine-similarity)))
      (format stream "TEST SIZE: ~A~%~%" (length mitigations))
      (print-nodes compass-tree stream))))

(defun compass-teak (this projects alpha beta &key (distance-func 'cosine-similarity))
  (let* ((test this)
	 (projects (remove test projects))
	 (compass-tree (compass projects :min-cluster-size 4 :distance-func distance-func))
	 (pruned-tree (variance-prune compass-tree :alpha alpha :beta beta))
	 (actual (first (last test)))
	 (predicted 0))

    (labels ((walk (c-node)
	       (if (< (node-variance c-node)
		      (weighted-variance c-node))
		   (setf predicted (median (mapcar #'first (mapcar #'last (node-contents c-node)))))
		   (if (or (null (node-right c-node))
			   (null (node-left c-node)))
		       (progn
			 (unless (null (node-right c-node))
			   (walk (node-right c-node)))
			 (unless (null (node-left c-node))
			   (walk (node-left c-node))))
		       (if (> (weighted-variance (node-right c-node))
			      (weighted-variance (node-left c-node)))
			   (walk (node-left c-node))
			   (walk (node-right c-node)))))))
      (walk pruned-tree))
    (mre actual predicted)))

(defun compass-defect-1up (this projects alpha beta &key (distance-func 'cosine-similarity) (lives 3))
  (let* ((test this)
	 (projects (remove test projects))
	 (compass-tree (compass projects :min-cluster-size 4 :distance-func distance-func :variance-func 'entropy))
	 (pruned-tree (variance-prune compass-tree :alpha alpha :beta beta))
	 (actual (first (last test)))
	 (true-votes 0)
	 (false-votes 0)
	 (lives-left lives))
    (labels ((walk (c-node)
	       (if (< (node-variance c-node)
		      (weighted-variance c-node))
		   (dolist (instance (node-contents c-node))
		     (let* ((result (first (last instance))))
		       (if (equal result 'TRUE)
			   (incf true-votes)
			   (incf false-votes))))
		   (if (or (null (node-right c-node))
			   (null (node-left c-node)))
		       (progn 
			 (unless (null (node-right c-node))
			   (walk (node-right c-node)))
			 (unless (null (node-left c-node))
			   (walk (node-left c-node))))
		       (if (> (weighted-variance (node-right c-node))
			      (weighted-variance (node-left c-node)))
			   (walk (node-left c-node))
			   (walk (node-right c-node)))))))
      (walk pruned-tree))
      (if (> true-votes false-votes) 'TRUE 'FALSE)))
	    
      
    
	 

(defun compass-defect (this projects alpha beta &key (distance-func 'cosine-similarity))
  (let* ((test this)
	 (projects (remove test projects))
	 (compass-tree (compass projects :min-cluster-size 4 :distance-func distance-func :variance-func 'entropy))
	 (pruned-tree (variance-prune compass-tree :alpha alpha :beta beta))
	 (actual (first (last test)))
	 (true-votes 0)
	 (false-votes 0))

    (labels ((walk (c-node)
	       (if (< (node-variance c-node)
		      (weighted-variance c-node))
		   (dolist (instance (node-contents c-node))
		     (let* ((result (first (last instance))))
		       (if (equal result 'TRUE)
			   (incf true-votes)
			   (incf false-votes))))
		   (if (or (null (node-right c-node))
			   (null (node-left c-node)))
		       (progn
			 (unless (null (node-right c-node))
			   (walk (node-right c-node)))
			 (unless (null (node-left c-node))
			   (walk (node-left c-node))))
		       (if (> (weighted-variance (node-right c-node))
			      (weighted-variance (node-left c-node)))
			   (walk (node-left c-node))
			   (walk (node-right c-node)))))))
      (walk pruned-tree)
(print true-votes)
(print false-votes)
(if (> true-votes false-votes) 'TRUE 'FALSE))))

(defun compass-teak-prebuilt (this compass-tree)
  "The oracle requires having a tree already built and returns the
   predicted value, not the mre."
  (let* ((test this)
	 (actual (first (last test)))
	 (predicted 0))

    (labels ((walk (c-node)
	       (if (< (node-variance c-node)
		      (weighted-variance c-node))
		   (setf predicted (median (mapcar #'first (mapcar #'last (node-contents c-node)))))
		   (if (or (null (node-right c-node))
			   (null (node-left c-node)))
		       (progn
			 (unless (null (node-right c-node))
			   (walk (node-right c-node)))
			 (unless (null (node-left c-node))
			   (walk (node-left c-node))))
		       (if (> (weighted-variance (node-right c-node))
			      (weighted-variance (node-left c-node)))
			   (walk (node-left c-node))
			   (walk (node-right c-node)))))))
      (walk compass-tree))
    predicted))

(defun tree-leaves (c-tree)
  (let (leaves)
    (labels ((walk (c-node)
	       (if (and (null (node-right c-node))
			(null (node-left c-node)))
		     (push (node-contents c-node) leaves))
	       (unless (null (node-right c-node))
		 (walk (node-right c-node)))
	       (unless (null (node-left c-node))
		 (walk (node-left c-node)))))
      (walk c-tree))
    leaves))

(defun max-leaf-size (c-node)
  (let ((maxs 0))
    (labels ((walk (c-node)
	       (if (and (null (node-right c-node))
			(null (node-left c-node)))
		   (if (> (length (node-contents c-node))
			  maxs)
		       (setf maxs (length (node-contents c-node))))
		   (progn
		     (unless (null (node-right c-node))
		       (walk (node-right c-node)))
		     (unless (null (node-left c-node))
		       (walk (node-left c-node)))))))
      (walk c-node))
    maxs))

(defun max-variance (c-tree)
  (let ((max 0))
    (labels ((walk (c-node)
	       (if (< max (realpart (node-variance c-node)))
		   (setf max (realpart (node-variance c-node))))
	       (unless (null (node-right c-node))
		 (walk (node-right c-node)))
	       (unless (null (node-left c-node))
		 (walk (node-left c-node)))))
      (walk c-tree))
    max))

(defun max-leaf-variance (c-tree)
  (let ((max 0))
    (labels ((walk (c-node)
	       (if (and
		    (and (null (node-right c-node))
			 (null (node-left c-node)))
		    (< max (realpart (node-variance c-node))))
		   (setf max (realpart (node-variance c-node))))
	       (unless (null (node-right c-node))
		 (walk (node-right c-node)))
	       (unless (null (node-left c-node))
		 (walk (node-left c-node)))))
      (walk c-tree))
    max))

(defun sorted-leaf-variance (c-tree)
  (let (v)
    (labels ((walk (c-node)
	       (if (and
		    (null (node-right c-node))
		    (null (node-left c-node)))
		   (push (node-variance c-node) v))
	       (unless (null (node-right c-node))
		 (walk (node-right c-node)))
	       (unless (null (node-left c-node))
		 (walk (node-left c-node)))))
      (walk c-tree))
    (sort v #'>)))

(defun strip-danglers (c-tree)
  (labels ((walk (c-node)
	     (unless (null (node-right c-node))
	       (if (= (length (node-contents (node-right c-node))) 1)
		   (setf (node-right c-node) nil)))
	     (unless (null (node-left c-node))
	       (if (= (length (node-contents (node-left c-node))) 1)
		   (setf (node-left c-node) nil)))
	     (unless (null (node-right c-node))
	       (walk (node-right c-node)))
	     (unless (null (node-left c-node))
	       (walk (node-left c-node)))))
    (walk c-tree))
  c-tree)