(defun k-predict (this data k &key (distance-func 'cosine-similarity))
  "Use the k nearest neighbors to predict"
  (let* ((representative this)
	 (data (remove representative (copy-list data)))
	 closest-list)
    (if (< (length data) k)
	(setf k (length data)))
    (dotimes (n k)
      (let ((closest (closest-to representative data :distance-func distance-func)))
	(push closest closest-list)
	(setf data (remove closest data))))
    (let ((predicted (median (mapcar #'first (mapcar #'last closest-list)))))
      (mre (first (last representative)) predicted))))

(defun best-k-predict (this data &key (distance-func 'cosine-similarity))
  "Loop until we have a best-k mre result"
  (let* ((representative this)
	 (actual (first (last representative)))
	 (data (remove representative (copy-list data)))
	 (preserve (copy-list data))
	 (data (random-subset (copy-list data)))
	 (best-mre 99999999)
	 (best-k 0))
    (dotimes (n (1- (length data)))
      (let* ((this-data (subseq data 0 (1+ n)))
	     (predicted (median (mapcar #'first (mapcar #'last this-data)))))
	(let* ((current-mre (mre actual predicted)))
	  (if (< current-mre best-mre)
	      (progn (setf best-mre current-mre)
		     (setf best-k (1+ n)))))))
    (if (= 0 best-k)
	(incf best-k))
    (k-predict preserve best-k :distance-func distance-func)))

(defun random-subset (l)
  (let* ((r (my-random-int (length l))))
    (if (= r 0)
	(incf r))
    (subseq (shuffle-n l 20) 0 r)))
