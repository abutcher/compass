(defun k-means (k data)
  (k-means-prim k (make-array `(,(length data)
                                ,(length (first data)))
			      :initial-contents data)))		   

(defun k-means-prim (k data)
  "k-means: performs a k-means clustering."
  (let ((memberof (make-array (array-dimension data 0)
                              :initial-element nil))
	(oldmemberof (make-array (array-dimension data 0)
                                 :initial-element nil))
	(num.in.cluster (make-array k :initial-element 0))
	(centroids (make-array (list k (array-dimension data 1))
                               :initial-element 0))
	(distances (make-array (list (array-dimension data 0) k)
                               :initial-element nil))
	(tempmin nil)
	(finaldata
         (adjust-array data
                       (list (array-dimension data 0)
                             (+ (array-dimension data 1) 1)))))
    (dotimes (i (array-dimension data 0))
      (setf (aref memberof i) (mod i k))
      (setf (aref num.in.cluster (mod i k))
            (+ (aref num.in.cluster (mod i k)) 1)))
    (dotimes (i (array-dimension data 0))
      (dotimes (j (array-dimension data 1))
	(setf (aref centroids (aref memberof i) j)
	      (+ (/ (aref data i j)
		    (aref num.in.cluster (aref memberof i)))
		 (aref centroids (aref memberof i) j)))))
    (dotimes (iteration (array-dimension data 0) memberof)
      (if (equalp oldmemberof memberof)
	  (return memberof))
      (dotimes (i (array-dimension memberof 0))
	(setf (aref oldmemberof i) (aref memberof i)))
      (setf distances (set-distance-matrix2 data centroids))
      (dotimes (i (array-dimension distances 0))
	(setf tempmin (aref distances i 0))
	(dotimes (j (array-dimension distances 1))
	  (cond ((<= (aref distances i j) tempmin)
		 (setf tempmin (aref distances i j))
		 (setf (aref memberof i) j)))))
      (setf num.in.cluster (make-array k :initial-element 0))
      (dotimes (i (array-dimension memberof 0))
	(setf (aref num.in.cluster (aref memberof i))
              (+ (aref num.in.cluster (aref memberof i)) 1)))
      (setf centroids (make-array (list k (array-dimension data 1))
                                  :initial-element 0))
      (dotimes (i (array-dimension data 0))
	(dotimes (j (array-dimension data 1))
	  (setf (aref centroids (aref memberof i) j)
		(+ (/ (aref data i j)
		      (aref num.in.cluster (aref memberof i)))
		   (aref centroids (aref memberof i) j))))))
    (dotimes (i (array-dimension data 0))
      (setf (aref finaldata i (- (array-dimension finaldata 1) 1))
            (aref memberof i)))
    finaldata))

(defun set-distance-matrix2 (data1 data2)
  "set-distance-matrix2: Creates and returns an array 
   representing the distances between objects of two sets"
  (let ((distancearray
         (make-array (list (array-dimension data1 0)
                           (array-dimension data2 0)) :initial-element 0))
        (sum 0))
    (dotimes (i (array-dimension distancearray 0) distancearray)
      (dotimes (j (array-dimension distancearray 1))
        (setf sum 0)
        (dotimes (k (array-dimension data1 1))
          (setf sum (+ sum (expt (- (aref data1 i k) (aref data2 j k)) 2))))
        (setf (aref distancearray i j) (sqrt sum))))))

(defun array-to-list (a &optional (dims (array-dimensions a)) (start 0)) 
  (if (not dims) 
      (row-major-aref a start) 
      (let ((dim1 (first dims)) (more-dims (rest dims))) 
	(loop repeat dim1 
	   for j from start by (apply #'* more-dims) 
	   collect (array-to-list a more-dims j)))))

(defun meat-processor (k k-means-output)
  (let* ((tbl-egs (array-to-list k-means-output))
	 (clusters))
    (dotimes (n k)      
      (let (temporary-storage)
	(dolist (eg tbl-egs)
	  (if (= (first (last eg)) n)
	      (push (rmnth (1- (length eg)) eg) temporary-storage)))
	(push temporary-storage clusters)))
    clusters))

